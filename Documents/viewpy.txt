import base64
import datetime
import json
import os
import sys
import jenkinsapi
from jenkinsapi.custom_exceptions import NotFound
import requests
import traceback
from django.http import HttpResponse, JsonResponse
from django.shortcuts import render, redirect
from django.views.decorators.cache import never_cache
from django.views.decorators.csrf import csrf_exempt
from websocket import create_connection
from dbConnectors.mongo_wrapper import MongoWrapper
from scripts.html_wrapper import HTMLWrapper
from pprint import pprint
import time

'''
Created by: 
K-M Samiul Haque
QE CO-OP
Summer, 2017
'''

# GLOABAL Variables for functions

# Directory name of the files folder
FOLDER_NAME = "Files"
# Directory path to files folder
INPUT_FILE_DIRECTORY = os.path.dirname(os.path.realpath(sys.argv[0])) + "\\" + FOLDER_NAME + "\\input"
OUTPUT_FILE_DIRECTORY = os.path.dirname(os.path.realpath(sys.argv[0])) + "\\" + FOLDER_NAME + "\\output"

# Jenkins URL for building using API
BASE_URL = "http://se119815.devfg.rbc.com:8080/job/"
# List of column names in the Portal table
HEADER_LIST = ["ID",
               "Excel File Name",
               "Uploaded On",
               "Download Result",
               "Executed On",
               "Execution Log",
               "Function Name",
               "Environment",
               "Execute",
               "Delete"]

# Extra parameters that we want to use but not display in the columns for each row
EXTRA_PARAMS = ["PASS",
                "FAIL"]

# Options in popup.html
DATA = {"function_names": ["Z_PV_ACCEPTANCE_RFC",
                           "APPLY_PROGRAMS_CALC",
                           "Z_PV_DETERMIN_RFC",
                           "GENERATE_XML_CAC",
                           "EXCEL_CONVERT",
                           "SAVE_SRF_TO_DB"],
        "execution_env": ['CQ1',
                          'CQ2',
                          'CD1',
                          'CD2'],
        "ALM_Profiles": ['Apply_Program_Profile',
                         'Property_Valuation_Profile',
                         'Profile_3'],
        }

# for profile list under upload button
ALM_SET_PROFILES = DATA["ALM_Profiles"]

JENKINS_URL = 'http://se119815.devfg.rbc.com:8080/'

@never_cache
def abort_build(request):
    """
    try to abort the build for the a givne test
    """
    # wait for the build if it hasn't started to start and then stop it
    db = MongoWrapper()
    test_id = str(request.POST['TEST_ID'])
    DB_ROW = db.find_from_collection({'ID': test_id})
    temp, JOB_NAME, BUILD_NO = DB_ROW['Execution Log']
    print("Build number: " + str(int(BUILD_NO)))
    for _ in range(60):
        try:
            build = jenkinsapi.api.get_build(JENKINS_URL, JOB_NAME, int(BUILD_NO))
            pprint("Build number: " + str(int(BUILD_NO)))
            pprint("Build is: " + str(build))
            break
        except NotFound:
            pprint("Build pending")
            time.sleep(1)
        except:
            pprint(traceback.format_exc())
            break
    else:
        pprint("BUILD DOES NOT EXIST")
        return HttpResponse(False)

    pprint("Stopping test " + test_id + " " + JOB_NAME + " " + str(BUILD_NO))
    # update the UI status to FAILED
    result = build.stop()
    ws = create_connection("ws://10.101.129.174/datadriven/")
    ws.send(json.dumps({
        'stream': 'update_status',
        'payload': {
            'TEST_ID': MONGO_ROW_ID,
            'BUILD_ID': JENKINS_BUILD_ID,
            'STATUS': 0,
            'RESULT_FILE_NAME': "",
            'PASS': 'N/A',
            'FAIL': 'N/A'}
        }))
    return HttpResponse(result)



# Added never cache decorator to deny chaching from the client browser
@never_cache
def index(request):
    '''
    Renders our base html
    :param request: The request coming from the Client browser
    :return: Renders index.html and wraps it with the values
    from the database for the column headers
    '''
    # Connect to DB
    response_dict = {"header_names": HEADER_LIST, "ALM_Profiles": ALM_SET_PROFILES}
    return render(request=request, template_name="portal/index.html", context=response_dict)


# Added never cache decorator to deny chaching from the client browser
@never_cache
def execution_popup(request):
    '''
    Renders the popup.html to create a seperate view outside of the main view
    thus seperating execution from live rendering in main view
    :param request: The request coming from the Client browser
    :return: Renders popup.html passing in the row id from the GET params
    into the execute button
    '''
    popup_id = ""
    try:
        popup_id = str(request.GET["test_id"])
        DATA["popup_id"] = popup_id
    except:
        print("Couldn't get the TEST_ID")
    return render(request=request, template_name="portal/popup.html", context=DATA)


def data_dump(request):
    db = MongoWrapper()
    db_dump = HTMLWrapper(db.get_cursor()).wrap_data(header_keys=HEADER_LIST, extra_params=EXTRA_PARAMS)
    response_collection = {"data": db_dump}
    return JsonResponse(response_collection)



# Decorator to disable CSRF check to allow POST request to go through with the file payload
@csrf_exempt
def file_transfer(request):
    '''
    Recieves the file sent in the index view via AJAX and saves it in the Files directory,
    also triggers jenkins build for ALM unless
    :param request:
    :return:
    '''
    create_alm_test = str(request.POST["alm_create"])
    input_file = request.FILES["input_file"]
    alm_profile_upload = str(request.POST["alm_profile_upload"])
    print(request.POST)
    if not save_file(input_file, create_alm_test,alm_profile_upload):
        return HttpResponse("File already exists")
    else:
        return HttpResponse("File Uploaded")



def folder_exists():
    if not os.path.isdir(INPUT_FILE_DIRECTORY):
        os.makedirs(INPUT_FILE_DIRECTORY)
    if not os.path.isdir(OUTPUT_FILE_DIRECTORY):
        os.makedirs(OUTPUT_FILE_DIRECTORY)
    return True if (os.path.isdir(INPUT_FILE_DIRECTORY) and os.path.isdir(OUTPUT_FILE_DIRECTORY)) else False


def save_file(fileobj, create_alm_test,alm_profile):
    if folder_exists():
        file_path = INPUT_FILE_DIRECTORY + "\\" + fileobj.name
        if os.path.isfile(file_path):
            print("FILE ALREADY EXISTS")
            return False
        else:
            with open(file_path, "wb+") as destination:
                for chunk in fileobj.chunks():
                    destination.write(chunk)
            print(file_path)
            db = MongoWrapper()
            test_id = db.get_highest_id()
            temp = {
                #
                "alm_profile_upload":alm_profile,
                "input_file": fileobj.name,
                "ID": test_id,
                "Excel File Name": [test_id, fileobj.name],
                "Uploaded On": str(datetime.datetime.now())[:-7],
                "Download Result": "",
                "Executed On": "",
                "Execution Log": "Uploading",
                "Function Name": "TRIGGER_ALM_SE137611",
                "Execute": test_id,
                "Environment": "",
                "Delete": test_id,
                "input_path": INPUT_FILE_DIRECTORY,
                "output_path": OUTPUT_FILE_DIRECTORY,
                "create_alm": create_alm_test,
                "PASS": "N/A",
                "FAIL": "N/A",
                'result_file': '',
                'test_comments': 'No Comments',
                'test_description': 'No Description',
                'test_id': '',
                'test_instance_id': '',
                'test_result': 'No Run',
                'test_run_id': '',
                'test_set_id': '',
                'automation': False,
                'ALM_Profile': ""
            }
            db.insert_into_collection(temp)
            db.update_one({"ID":test_id}, {"Execution Log": "Uploaded"})
            print("INSERTED INTO DB")
            if create_alm_test == 'true':
                alm_url = BASE_URL + "TRIGGER_ALM_SE137611/buildWithParameters"
                alm_exec_params = {'token': 'zpvacceptancerfcLINX',
                                   "MONGO_ROW_ID": test_id,
                                   "OPTION": "CREATE",
                                   "ALM_PROFILE":alm_profile
                                   }
                requests.get(alm_url, params=alm_exec_params)
                print("CREATED TEST CASE")

            return True
    else:
        print("FOLDER DOES NOT EXIST")
        return False


def download_original(request, download_id):
    print(download_id)
    db = MongoWrapper()
    try:
        original_file_name = db.find_from_collection({"ID": download_id})["input_file"]
        path = INPUT_FILE_DIRECTORY + "\\" + original_file_name
        print(path)
        if os.path.exists(path):
            with open(path, 'rb') as fh:
                response = HttpResponse(fh.read(), content_type="application/excel")
                response['Content-Disposition'] = 'inline; filename=' + os.path.basename(path)
                return response
        return redirect("/datadriven")
    except:
        return redirect("/datadriven")


def download_result(request, download_id):
    print(download_id)
    db = MongoWrapper()
    try:
        result_file_name = db.find_from_collection({"ID": download_id})["result_file"]
        if result_file_name != "":
            path = OUTPUT_FILE_DIRECTORY + "\\" + result_file_name
            print(path)
            if os.path.exists(path):
                with open(path, 'rb') as fh:
                    file_name = os.path.basename(path)
                    ret_file_name = file_name[:file_name.rfind(".")] + "_result" + file_name[file_name.rfind("."):]
                    response = HttpResponse(fh.read(), content_type="application/excel")
                    response['Content-Disposition'] = 'inline; filename=' + ret_file_name
                    return response
        return redirect("/datadriven")
    except:
        return redirect("/datadriven")


@csrf_exempt
def execute_function(request):
    env = str(request.POST['Env']).strip()
    # progfile = open('C:\\nginx\\a.txt', 'a')
    # progfile.write(str(env))
    # progfile.close()
    test_id = str(request.POST['ID']).strip()
    function_name = str(request.POST['Function_Name']).strip()
    alm_profile = str(request.POST['ALM_Profile']).strip()
    url_inp = BASE_URL + function_name + "/buildWithParameters"
    alm_url = BASE_URL + "TRIGGER_ALM_SE137611/buildWithParameters"
    db = MongoWrapper()
    file_name = db.find_from_collection({"ID": test_id})['input_file']
    exec_params = {'token': 'zpvacceptancerfcLINX',
                   "EXCEL_FILE_NAME": '"%s"' % file_name,
                   "EXECUTION_ENV": env,
                   "TEST_ID": test_id}
    requests.get(url_inp, params=exec_params)
    update_record = {"Executed On": str(datetime.datetime.now())[:-7],
                     "Function Name": function_name,
                     "Environment": env,
                     "Execution Log": "Executing",
                     "ALM_Profile": alm_profile
                     }
    if not db.update_one({"ID": test_id}, update_record):
        return HttpResponse("Execution Failed")
    if db.find_from_collection({"ID": test_id})["create_alm"]=='true':
        alm_exec_params = {'token': 'zpvacceptancerfcLINX',
                           "ALM_PROFILE": alm_profile,
                           "MONGO_ROW_ID": test_id,
                           "OPTION": "RUN"
                           }
        requests.get(alm_url, params=alm_exec_params)
        print("CREATED TEST SET")
    return HttpResponse("Execution started")


@csrf_exempt
def delete_test_case(request):
    test_id = str(request.POST['TEST_ID']).strip()
    db = MongoWrapper()
    ret_dict = db.find_from_collection({"ID": str(test_id)})
    if ret_dict["ALM_Profile"] == "":
        db.remove_from_collection({"ID": str(test_id)})
        return HttpResponse(True)
    else:
        del ret_dict["_id"]
        db.remove_from_collection({"ID": str(test_id)})
        if db.find_from_collection({"ID": test_id})["create_alm"]=='true':
            alm_url = BASE_URL + "TRIGGER_ALM_SE137611/buildWithParameters"
            alm_exec_params = {'token': 'zpvacceptancerfcLINX',
                               "MONGO_ROW_ID": test_id,
                               "OPTION": "DELETE",
                               "DB_ROW": base64.b64encode(json.dumps(ret_dict, separators=(',', ':'))),
                               "ALM_PROFILE": ret_dict["ALM_Profile"]
                               }
            requests.get(alm_url, params=alm_exec_params)
        return HttpResponse(True)